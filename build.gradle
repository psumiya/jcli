buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.2")
        classpath("io.github.classgraph:classgraph:4.8.165")
    }
}

plugins {
    id("com.gradleup.shadow") version "9.3.0"
    id("java")
    id("application")
    id("org.graalvm.buildtools.native") version "0.11.2"
}



version = "0.0.1-beta"
group = "jcli"

repositories {
    mavenCentral()
}

dependencies {
    annotationProcessor("info.picocli:picocli-codegen:4.6.3")
    implementation("info.picocli:picocli:4.6.3")
    implementation("org.yaml:snakeyaml:2.2")
    implementation("ch.qos.logback:logback-classic:1.2.10")
    
    // Test dependencies
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.1")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.1")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

application {
    mainClass.set("jcli.JcliCommand")
}


java {
    sourceCompatibility = JavaVersion.VERSION_25
    targetCompatibility = JavaVersion.VERSION_25
}

graalvmNative {
    binaries {
        main {
            imageName.set("jcli") 
            buildArgs.add("--verbose")
        }
    }
}

test {
    useJUnitPlatform()
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}"]
}

import org.yaml.snakeyaml.Yaml
import groovy.json.JsonBuilder
import io.github.classgraph.ClassGraph





task packageNative(type: Tar) {
    dependsOn 'nativeCompile'
    description = "Packages the native binary into a tar.gz for distribution"
    group = "distribution"

    def arch = System.getProperty("os.arch")
    // Normalize architecture names
    if (arch == "amd64") arch = "x86_64"
    
    // We assume OSX for now as per requirements, but could expand later
    archiveFileName = "jcli-${project.version}-osx-${arch}.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP



    into("bin") {
        from("build/native/nativeCompile") {
            include "jcli"
        }
    }
    
    doLast {
        println "Created distribution: ${destinationDirectory.get()}/${archiveFileName.get()}"
    }
}

task generateReflectConfig {
    def commandsFile = file("src/main/resources/commands.yaml")
    def reflectConfigFile = file("src/main/resources/META-INF/native-image/jcli/jcli/reflect-config.json")
    def commandIndexFile = file("src/main/resources/command-index.json")
    
    inputs.file(commandsFile)
    outputs.file(reflectConfigFile)
    outputs.file(commandIndexFile)
    
    doLast {
        if (!commandsFile.exists()) {
             throw new GradleException("commands.yaml not found at ${commandsFile}")
        }
        
        def yaml = new Yaml()
        def data = yaml.load(commandsFile.newInputStream())
        def explicitCommands = data['commands'] ?: [] // Handle null if only scanPackages is present
        // Extract command list from the nested structure if it exists, or treat it as list of maps
        if (data['commands'] instanceof List) {
             explicitCommands = data['commands']
        }
        
        def scanPackages = data['scanPackages'] ?: []
        
        def reflectionEntries = []
        def commandIndex = [:]
        
        // 1. Process explicitly defined commands
        explicitCommands.each { cmd ->
            if (cmd instanceof Map && cmd.containsKey('className')) {
                reflectionEntries << [
                    name: cmd['className'],
                    queryAllPublicMethods: true
                ]
            }
        }
        
        // 2. Scan packages
        if (scanPackages) {
            println "Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(
                    "java.util.concurrent", 
                    "java.util.logging", 
                    "java.lang.invoke", 
                    "java.lang.instrument", 
                    "java.lang.reflect", 
                    "java.util.stream",
                    "java.lang.management",
                    "java.lang.module",
                    "java.lang.ref",
                    "java.lang.foreign",
                    "java.util.zip",
                    "java.util.jar",
                    "java.util.prefs",
                    "java.util.regex",
                    "java.util.spi",
                    "java.util.random",
                    "java.util.function"
                )
                .scan()
            
            scanResult.getAllClasses().forEach { classInfo ->
                if (classInfo.isPublic() && !classInfo.isAbstract() && !classInfo.isInnerClass() && 
                    !classInfo.extendsSuperclass("java.lang.Throwable") &&
                    !classInfo.implementsInterface("java.util.Collection") &&
                    !classInfo.implementsInterface("java.util.Map") &&
                    !classInfo.implementsInterface("java.util.Iterator") &&
                    !classInfo.getName().startsWith("java.util.Optional") &&
                    !classInfo.getName().startsWith("java.util.Observable") &&
                    !classInfo.getName().equals("java.util.BitSet") &&
                    !classInfo.getName().equals("java.util.EventObject") &&
                    !classInfo.getName().equals("java.util.ServiceLoader") &&
                    !classInfo.getName().equals("java.util.Timer") &&
                    !classInfo.getName().equals("java.util.StringJoiner") &&
                    !classInfo.getName().equals("java.util.StringTokenizer") &&
                    !classInfo.getName().equals("java.util.PropertyResourceBundle") &&
                    !classInfo.getName().equals("java.util.PropertyPermission") &&
                    !classInfo.getName().equals("java.util.SimpleTimeZone") &&
                    !classInfo.getName().equals("java.util.Collections") &&
                    !classInfo.getName().endsWith("SummaryStatistics") &&
                    !classInfo.getName().equals("java.util.FormattableFlags") &&
                    !classInfo.getName().equals("java.util.GregorianCalendar")) {
                     def className = classInfo.getName()
                     def simpleName = classInfo.getSimpleName()
                     
                     // Add to reflection config
                     reflectionEntries << [
                         name: className,
                         queryAllPublicMethods: true,
                         allDeclaredConstructors: true,
                         allPublicConstructors: true
                     ]
                     
                     // Add to command index (SimpleName -> FullName)
                     // If collision, keep existing (first wins) or warn? For now, silent overwrite or ignore. 
                     // Let's protect against duplicates by checking.
                     if (!commandIndex.containsKey(simpleName)) {
                         commandIndex[simpleName] = className
                     }
                }
            }
        }

        // Add CommandConfig for generic command loading
        reflectionEntries << [
            name: "jcli.config.CommandConfig",
            allDeclaredConstructors: true,
            allPublicConstructors: true,
            allDeclaredFields: true,
            allPublicMethods: true
        ]
        
        reflectConfigFile.parentFile.mkdirs()
        reflectConfigFile.text = new JsonBuilder(reflectionEntries).toPrettyString()
        
        commandIndex.each { k, v -> 
            println "Indexed: ${k} -> ${v}" 
        }
        
        commandIndexFile.parentFile.mkdirs()
        commandIndexFile.text = new JsonBuilder(commandIndex).toPrettyString()
        
        println "Generated reflect-config.json with ${reflectionEntries.size()} entries."
        println "Generated command-index.json with ${commandIndex.size()} entries."
    }
}

processResources.dependsOn generateReflectConfig
