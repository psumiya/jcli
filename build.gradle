buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.2")
        classpath("io.github.classgraph:classgraph:4.8.165")
    }
}

plugins {
    id("com.gradleup.shadow") version "9.3.0"
    id("java")
    id("application")
    id("org.graalvm.buildtools.native") version "0.11.2"
}



version = "0.0.2-beta"
group = "jcli"

repositories {
    mavenCentral()
}

dependencies {
    annotationProcessor("info.picocli:picocli-codegen:4.6.3")
    implementation("info.picocli:picocli:4.6.3")
    implementation("org.yaml:snakeyaml:2.2")
    implementation("org.slf4j:slf4j-nop:2.0.9")
    implementation("com.jayway.jsonpath:json-path:2.9.0")
    implementation("net.minidev:json-smart:2.5.0")
    
    // Test dependencies
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.1")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.1")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

application {
    mainClass.set("jcli.JcliCommand")
}


java {
    sourceCompatibility = JavaVersion.VERSION_19
    targetCompatibility = JavaVersion.VERSION_19
}

graalvmNative {
    binaries {
        main {
            imageName.set("jcli") 
            buildArgs.add("--verbose")
        }
    }
}

test {
    useJUnitPlatform()
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}", "-parameters"]
}


import org.yaml.snakeyaml.Yaml
import groovy.json.JsonBuilder
import io.github.classgraph.ClassGraph


// Shared configuration and logic
ext {
    rejectedPackages = [
        "java.util.concurrent",
        "java.util.jar",
        "java.util.logging",
        "java.util.prefs",
        "java.util.random",
        "java.util.regex",
        "java.util.spi",
        "java.util.stream",
        "java.util.zip",
        "java.lang.invoke", 
        "java.lang.instrument", 
        "java.lang.reflect", 
        "java.lang.management",
        "java.lang.module",
        "java.lang.ref",
        "java.lang.foreign",
        "java.util.function",
        "java.lang.annotation",
        "java.lang.classfile",
        "java.lang.constant",
        "com.jayway.jsonpath.internal",
        "com.jayway.jsonpath.spi"
    ] as String[]

    // Class names to reject
    rejectedClasses = [
        // 'com.jayway.jsonpath.Configuration', 
    ] as Set

    // Shared method to check if a single class should be processed
    // Note: Checks mostly on name basis
    shouldProcessClass = { classInfo ->
        // Standard exclusions
        if (!classInfo.isPublic() || classInfo.isAbstract() || classInfo.isInnerClass()) return false
        
        // Inheritance/Interface exclusions
        if (classInfo.extendsSuperclass("java.lang.Throwable")) return false
        if (classInfo.implementsInterface("java.util.Collection")) return false
        if (classInfo.implementsInterface("java.util.Map")) return false
        if (classInfo.implementsInterface("java.util.Iterator")) return false
        
        def name = classInfo.getName()
        // Package/Prefix exclusions
        if (name.startsWith("java.util.Optional")) return false
        if (name.startsWith("java.util.Observable")) return false
        if (name.startsWith("com.jayway.jsonpath.internal")) return false
        if (name.startsWith("com.jayway.jsonpath.spi")) return false

        // Specific class exclusions
        if (name == "java.util.BitSet") return false
        if (name == "java.util.EventObject") return false
        if (name == "java.util.ServiceLoader") return false
        if (name == "java.util.Timer") return false
        if (name == "java.util.StringJoiner") return false
        if (name == "java.util.StringTokenizer") return false
        if (name == "java.util.PropertyResourceBundle") return false
        if (name == "java.util.PropertyPermission") return false
        if (name == "java.util.SimpleTimeZone") return false
        if (name == "java.util.Collections") return false
        if (name.endsWith("SummaryStatistics")) return false
        if (name == "java.util.FormattableFlags") return false
        if (name == "java.util.GregorianCalendar") return false
        
        return true
    }
}

task packageNative(type: Tar) {
    dependsOn 'nativeCompile'
    description = "Packages the native binary into a tar.gz for distribution"
    group = "distribution"

    def arch = System.getProperty("os.arch")
    // Normalize architecture names
    if (arch == "amd64") arch = "x86_64"
    
    // We assume OSX for now as per requirements, but could expand later
    archiveFileName = "jcli-${project.version}-osx-${arch}.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP

    into("bin") {
        from("build/native/nativeCompile") {
            include "jcli"
        }
    }
    
    doLast {
        println "Created distribution: ${destinationDirectory.get()}/${archiveFileName.get()}"
    }
}

task generateReflectConfig {
    def commandsFile = file("src/main/resources/commands.yaml")
    def reflectConfigFile = file("src/main/resources/META-INF/native-image/jcli/jcli/reflect-config.json")
    def commandIndexFile = file("src/main/resources/command-index.json")
    
    inputs.file(commandsFile)
    outputs.file(reflectConfigFile)
    outputs.file(commandIndexFile)
    
    doLast {
        if (!commandsFile.exists()) {
             throw new GradleException("commands.yaml not found at ${commandsFile}")
        }
        
        def yaml = new Yaml()
        def data = yaml.load(commandsFile.newInputStream())
        def explicitCommands = data['commands'] ?: [] 
        if (data['commands'] instanceof List) {
             explicitCommands = data['commands']
        }
        
        def scanPackages = data['scanPackages'] ?: []
        
        def reflectionEntries = []
        def commandIndex = [:]
        
        // 1. Process explicit commands
        explicitCommands.each { cmd ->
            if (cmd instanceof Map && cmd.containsKey('className')) {
                reflectionEntries << [
                    name: cmd['className'],
                    queryAllPublicMethods: true
                ]
            }
        }
        
        // 2. Scan packages
        if (scanPackages) {
            println "Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(project.ext.rejectedPackages)
                .scan()
            
            scanResult.getAllClasses().forEach { classInfo ->
                if (project.ext.shouldProcessClass(classInfo)) {
                     def className = classInfo.getName()
                     def simpleName = classInfo.getSimpleName()
                     
                     // Add to reflection config
                     def methodsList = []
                     classInfo.getMethodInfo().each { method ->
                         if (method.isPublic()) {
                             def parameterTypes = method.getParameterInfo().collect { it.getTypeSignatureOrTypeDescriptor().toString() }
                             methodsList << [
                                 name: method.getName(),
                                 parameterTypes: parameterTypes
                             ]
                         }
                     }

                     reflectionEntries << [
                         name: className,
                         queryAllPublicMethods: true,
                         allDeclaredConstructors: true,
                         allPublicConstructors: true,
                         methods: methodsList
                     ]
                     
                     if (!commandIndex.containsKey(simpleName)) {
                         commandIndex[simpleName] = className
                     }
                }
            }
        }

        // Add CommandConfig for generic command loading
        reflectionEntries << [
            name: "jcli.config.CommandConfig",
            allDeclaredConstructors: true,
            allPublicConstructors: true,
            allDeclaredFields: true,
            allPublicMethods: true
        ]
        
        reflectConfigFile.parentFile.mkdirs()
        reflectConfigFile.text = new JsonBuilder(reflectionEntries).toPrettyString()
        
        commandIndex.each { k, v -> 
            println "Indexed: ${k} -> ${v}" 
        }
        
        commandIndexFile.parentFile.mkdirs()
        commandIndexFile.text = new JsonBuilder(commandIndex).toPrettyString()
        
        println "Generated reflect-config.json with ${reflectionEntries.size()} entries."
        println "Generated command-index.json with ${commandIndex.size()} entries."
    }
}

task generateDocsJson {
    dependsOn 'classes' 
    description = "Generates JSON data for the documentation site"
    group = "documentation"

    def docsFile = file("docs/data.json")
    def commandsFile = file("src/main/resources/commands.yaml")
    
    inputs.file(commandsFile)
    outputs.file(docsFile)
    
    doLast {
        def yaml = new Yaml()
        def data = commandsFile.exists() ? yaml.load(commandsFile.newInputStream()) : [:]
        def scanPackages = data['scanPackages'] ?: []
        
        def docsData = [
            generatedAt: new Date().toString(),
            version: project.version,
            commands: []
        ]
        
        def formatParams = { method ->
             def params = method.getParameterInfo()
             params.indices.collect { i ->
                 def param = params[i]
                 def typeName = param.getTypeDescriptor().toString().replaceAll('java\\.lang\\.', '').replaceAll('java\\.util\\.', '')
                 def paramName = param.getName()
                 if (paramName == null) paramName = "arg${i}"
                 "${typeName} ${paramName}"
             }
        }

        if (scanPackages) {
            println "Docs: Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(project.ext.rejectedPackages)
                .scan()
            
            // Helpers for filtering types
            def isTypeSupported = { typeSig ->
                def typeStr = typeSig.toString().replaceAll('java\\.lang\\.', '')
                def fullTypeStr = typeSig.toString()
                
                // Primitives and Arrays
                if (typeStr in ['int', 'long', 'boolean', 'double', 'float', 'short', 'byte', 'char', 'void']) return true
                if (typeStr.endsWith('[]')) return true
                
                // Core types
                if (typeStr == 'String') return true
                if (typeStr == 'CharSequence') return true
                if (typeStr == 'Object') return true
                if (typeStr == 'Class') return true
                
                // Wrappers
                if (typeStr in ['Integer', 'Long', 'Boolean', 'Double', 'Float', 'Short', 'Byte']) return true
                
                // Check if Enum
                def typeClassInfo = scanResult.getClassInfo(fullTypeStr)
                if (typeClassInfo && typeClassInfo.isEnum()) return true
                
                return false
            }

            def isReturnTypeSupported = { typeSig ->
                def typeStr = typeSig.toString()
                
                if (typeStr.contains("java.util.stream.")) return false
                if (typeStr == "java.util.Iterator") return false
                if (typeStr == "java.util.Spliterator") return false
                if (typeStr == "java.util.Enumeration") return false
                
                def typeClassInfo = scanResult.getClassInfo(typeStr)
                if (typeClassInfo) {
                    if (typeClassInfo.implementsInterface("java.util.Iterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Spliterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Enumeration")) return false
                    if (typeClassInfo.implementsInterface("java.util.stream.BaseStream")) return false
                }
                
                return true
            }

            scanResult.getAllClasses().forEach { classInfo ->
                if (project.ext.shouldProcessClass(classInfo)) {
                     
                     def methods = []
                     classInfo.getMethodInfo().each { method ->
                          if (method.isPublic() && !method.isConstructor()) {
                               def returnTypeSig = method.getTypeSignatureOrTypeDescriptor().getResultType()
                               def paramInfos = method.getParameterInfo()
                               
                               def allParamsSupported = paramInfos.every { param ->
                                   isTypeSupported(param.getTypeDescriptor())
                               }
                               
                               if (allParamsSupported && isReturnTypeSupported(returnTypeSig)) {
                                   methods << [
                                       name: method.getName(),
                                       signature: "${method.getName()}(${formatParams(method).join(', ')})",
                                       returnType: returnTypeSig.toString().replaceAll('java\\.lang\\.', ''),
                                       isStatic: method.isStatic()
                                   ]
                               }
                          }
                     }

                     docsData.commands << [
                         name: classInfo.getSimpleName(),
                         fullName: classInfo.getName(),
                         description: "Wrapper for ${classInfo.getName()}",
                         methods: methods.sort { it.name }
                     ]
                }
            }
        }
        
        docsData.commands.sort { it.name }
        
        docsFile.parentFile.mkdirs()
        docsFile.text = new JsonBuilder(docsData).toPrettyString()
        println "Generated docs/data.json with ${docsData.commands.size()} commands."
    }
}


processResources.dependsOn generateReflectConfig
