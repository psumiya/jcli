buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.2")
        classpath("io.github.classgraph:classgraph:4.8.165")
    }
}

plugins {
    id("com.gradleup.shadow") version "9.3.0"
    id("java")
    id("application")
    id("org.graalvm.buildtools.native") version "0.11.2"
}



version = "0.0.2-beta"
group = "jcli"

repositories {
    mavenCentral()
}

dependencies {
    annotationProcessor("info.picocli:picocli-codegen:4.6.3")
    implementation("info.picocli:picocli:4.6.3")
    implementation("org.yaml:snakeyaml:2.2")
    implementation("org.slf4j:slf4j-nop:2.0.9")
    implementation("com.jayway.jsonpath:json-path:2.9.0")
    implementation("net.minidev:json-smart:2.5.0")
    
    // Test dependencies
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.1")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.1")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.1")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    testImplementation("com.fasterxml.jackson.core:jackson-databind:2.14.2")
}

application {
    mainClass.set("jcli.JcliCommand")
}


java {
    sourceCompatibility = JavaVersion.VERSION_19
    targetCompatibility = JavaVersion.VERSION_19
}

graalvmNative {
    binaries {
        main {
            imageName.set("jcli") 
            buildArgs.add("--verbose")
        }
    }
}

test {
    useJUnitPlatform()
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}", "-parameters"]
}


import org.yaml.snakeyaml.Yaml
import groovy.json.JsonBuilder
import io.github.classgraph.ClassGraph


// Shared configuration and logic
ext {
    rejectedPackages = [
        "java.util.concurrent",
        "java.util.jar",
        "java.util.logging",
        "java.util.prefs",
        "java.util.random",
        "java.util.regex",
        "java.util.spi",
        "java.util.stream",
        "java.util.zip",
        "java.lang.invoke", 
        "java.lang.instrument", 
        "java.lang.reflect", 
        "java.lang.management",
        "java.lang.module",
        "java.lang.ref",
        "java.lang.foreign",
        "java.util.function",
        "java.lang.annotation",
        "java.lang.classfile",
        "java.lang.constant",
        "com.jayway.jsonpath.internal",
        "com.jayway.jsonpath.spi"
    ] as String[]

    // Class names to reject
    rejectedClasses = [
        // 'com.jayway.jsonpath.Configuration', 
    ] as Set

    // Shared method to check if a single class should be processed
    // Note: Checks mostly on name basis
    shouldProcessClass = { classInfo ->
        // Standard exclusions
        if (!classInfo.isPublic() || classInfo.isAbstract() || classInfo.isInnerClass()) return false
        
        // Inheritance/Interface exclusions
        if (classInfo.extendsSuperclass("java.lang.Throwable")) return false
        if (classInfo.implementsInterface("java.util.Collection")) return false
        if (classInfo.implementsInterface("java.util.Map")) return false
        if (classInfo.implementsInterface("java.util.Iterator")) return false
        
        def name = classInfo.getName()
        // Package/Prefix exclusions
        if (name.startsWith("java.util.Optional")) return false
        if (name.startsWith("java.util.Observable")) return false
        if (name.startsWith("com.jayway.jsonpath.internal")) return false
        if (name.startsWith("com.jayway.jsonpath.spi")) return false

        // Specific class exclusions
        if (name == "java.util.BitSet") return false
        if (name == "java.util.EventObject") return false
        if (name == "java.util.ServiceLoader") return false
        if (name == "java.util.Timer") return false
        if (name == "java.util.StringJoiner") return false
        if (name == "java.util.StringTokenizer") return false
        if (name == "java.util.PropertyResourceBundle") return false
        if (name == "java.util.PropertyPermission") return false
        if (name == "java.util.SimpleTimeZone") return false
        if (name == "java.util.Collections") return false
        if (name.endsWith("SummaryStatistics")) return false
        if (name == "java.util.FormattableFlags") return false
        if (name == "java.util.GregorianCalendar") return false
        
        return true
    }
}

task packageNative(type: Tar) {
    dependsOn 'nativeCompile'
    description = "Packages the native binary into a tar.gz for distribution"
    group = "distribution"

    def arch = System.getProperty("os.arch")
    // Normalize architecture names
    if (arch == "amd64") arch = "x86_64"
    
    // We assume OSX for now as per requirements, but could expand later
    archiveFileName = "jcli-${project.version}-osx-${arch}.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP

    into("bin") {
        from("build/native/nativeCompile") {
            include "jcli"
        }
    }
    
    doLast {
        println "Created distribution: ${destinationDirectory.get()}/${archiveFileName.get()}"
    }
}

task generateReflectConfig {
    def commandsFile = file("src/main/resources/commands.yaml")
    def reflectConfigFile = file("src/main/resources/META-INF/native-image/jcli/jcli/reflect-config.json")
    def commandIndexFile = file("src/main/resources/command-index.json")
    
    inputs.file(commandsFile)
    outputs.file(reflectConfigFile)
    outputs.file(commandIndexFile)
    
    doLast {
        if (!commandsFile.exists()) {
             throw new GradleException("commands.yaml not found at ${commandsFile}")
        }
        
        def yaml = new Yaml()
        def data = yaml.load(commandsFile.newInputStream())
        def explicitCommands = data['commands'] ?: [] 
        if (data['commands'] instanceof List) {
             explicitCommands = data['commands']
        }
        
        def scanPackages = data['scanPackages'] ?: []
        
        def reflectionEntries = []
        def commandIndex = [:]
        
        // 1. Process explicit commands
        explicitCommands.each { cmd ->
            if (cmd instanceof Map && cmd.containsKey('className')) {
                reflectionEntries << [
                    name: cmd['className'],
                    queryAllPublicMethods: true
                ]
            }
        }
        
        // 2. Scan packages
        if (scanPackages) {
            println "Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(project.ext.rejectedPackages)
                .scan()
            
            scanResult.getAllClasses().forEach { classInfo ->
                if (project.ext.shouldProcessClass(classInfo)) {
                     def className = classInfo.getName()
                     def simpleName = classInfo.getSimpleName()
                     
                     // Add to reflection config
                     def methodsList = []
                     classInfo.getMethodInfo().each { method ->
                         if (method.isPublic()) {
                             def parameterTypes = method.getParameterInfo().collect { it.getTypeSignatureOrTypeDescriptor().toString() }
                             methodsList << [
                                 name: method.getName(),
                                 parameterTypes: parameterTypes
                             ]
                         }
                     }

                     reflectionEntries << [
                         name: className,
                         queryAllPublicMethods: true,
                         allDeclaredConstructors: true,
                         allPublicConstructors: true,
                         methods: methodsList
                     ]
                     
                     if (!commandIndex.containsKey(simpleName)) {
                         commandIndex[simpleName] = className
                     }
                }
            }
        }

        // Add CommandConfig for generic command loading
        reflectionEntries << [
            name: "jcli.config.CommandConfig",
            allDeclaredConstructors: true,
            allPublicConstructors: true,
            allDeclaredFields: true,
            allPublicMethods: true
        ]
        
        reflectConfigFile.parentFile.mkdirs()
        reflectConfigFile.text = new JsonBuilder(reflectionEntries).toPrettyString()
        
        commandIndex.each { k, v -> 
            println "Indexed: ${k} -> ${v}" 
        }
        
        commandIndexFile.parentFile.mkdirs()
        commandIndexFile.text = new JsonBuilder(commandIndex).toPrettyString()
        
        println "Generated reflect-config.json with ${reflectionEntries.size()} entries."
        println "Generated command-index.json with ${commandIndex.size()} entries."
    }
}

task generateDocsJson {
    dependsOn 'classes' 
    description = "Generates JSON data for the documentation site"
    group = "documentation"

    def docsFile = file("docs/data.json")
    def commandsFile = file("src/main/resources/commands.yaml")
    
    inputs.file(commandsFile)
    outputs.file(docsFile)
    
    doLast {
        def yaml = new Yaml()
        def data = commandsFile.exists() ? yaml.load(commandsFile.newInputStream()) : [:]
        def scanPackages = data['scanPackages'] ?: []
        def explicitExamples = data['examples'] ?: [:]
        
        def docsData = [
            generatedAt: new Date().toString(),
            version: project.version,
            commands: []
        ]
        
        def formatParams = { method ->
             def params = method.getParameterInfo()
             params.indices.collect { i ->
                 def param = params[i]
                 def typeName = param.getTypeDescriptor().toString().replaceAll('java\\.lang\\.', '').replaceAll('java\\.util\\.', '')
                 def paramName = param.getName()
                 if (paramName == null) paramName = "arg${i}"
                 "${typeName} ${paramName}"
             }
        }

        // Initialize scanResult variable
        def scanResult = null

        // Heuristic Example Generator
        def generateExample = { classInfo, method ->
            def className = classInfo.getName()
            def methodName = method.getName()
            def key = "${className}.${methodName}".toString()
            
            // 1. Explicit Override
            if (explicitExamples.containsKey(key)) {
                def args = explicitExamples[key]
                return "jcli ${classInfo.getSimpleName()} ${methodName} ${args.join(' ')}"
            }

            // Helpers for heuristics
            def getHeuristicValue = { type ->
                def typeStr = type.toString().replaceAll('java\\.lang\\.', '')
                if (typeStr == 'int' || typeStr == 'Integer' || typeStr == 'long' || typeStr == 'Long') return "0"
                if (typeStr == 'double' || typeStr == 'Double' || typeStr == 'float' || typeStr == 'Float') return "0.0"
                if (typeStr == 'boolean' || typeStr == 'Boolean') return "false"
                if (typeStr == 'String' || typeStr == 'CharSequence') return '"test"'
                if (typeStr == 'byte' || typeStr == 'Byte') return "0"
                if (typeStr == 'short' || typeStr == 'Short') return "0"
                if (typeStr == 'char' || typeStr == 'Character') return "a"
                
                // Enums
                try {
                    def typeClass = scanResult.getClassInfo(type.toString())
                    if (typeClass && typeClass.isEnum()) {
                        def enumConstants = typeClass.getEnumConstants()
                        if (enumConstants && enumConstants.size() > 0) {
                            return enumConstants[0].toString()
                        }
                    }
                } catch (Exception e) {}

                return null // Unknown/Complex type
            }

            def methodArgs = []
            def params = method.getParameterInfo()
            for (param in params) {
                 def val = getHeuristicValue(param.getTypeDescriptor())
                 if (val == null) return null // Cannot generate arg for this param
                 methodArgs << val
            }

            // Strategy Determination (Simplified replica of UniversalCommand logic)
            // Static Method
            if (method.isStatic()) {
                return "jcli ${classInfo.getSimpleName()} ${methodName} ${methodArgs.join(' ')}"
            }

            // Instance Method
            // We need an instance. 
            // 1. Is it a String class? Instance is just a string.
            if (className == "java.lang.String") {
                 // heuristic: use "test" as instance
                 return "jcli String ${methodName} \"test\" ${methodArgs.join(' ')}"
            }

            // 2. Does it have a constructor that takes String or primitive?
            // (We simply check if we can generate a "default" instance arg, which usually matches 
            // what UniversalCommand supports via createInstance or just passing the string)
            
            // If the class itself is supported by getHeuristicValue logic (primitives wrappers etc), we can use that.
            // But usually this is for complex objects.
            
            // Check constructors
            def hasUsableConstructor = classInfo.getConstructorInfo().any { ctor ->
                 if (ctor.getParameterInfo().length == 1) {
                     def pType = ctor.getParameterInfo()[0].getTypeDescriptor()
                     return getHeuristicValue(pType) != null
                 }
                 return false
            }

            if (hasUsableConstructor) {
                 // We assume we can construct it from a simple value.
                 // For the example, we just need *some* value that works.
                 // "0" or "test" is usually a safe bet for the CLI arg that becomes the instance.
                 return "jcli ${classInfo.getSimpleName()} ${methodName} \"0\" ${methodArgs.join(' ')}"
            }

            // 3. Default constructor?
            def hasDefaultConstructor = classInfo.getConstructorInfo().any { it.getParameterInfo().length == 0 }
            if (hasDefaultConstructor) {
                 // UniversalCommand supports "hybrid" where if default constructor exists, 
                 // we might not need an instance arg if we passed all method args, 
                 // OR we can pass an empty string/placeholder? 
                 // Actually UniversalCommand executeHybrid checks:
                 // "If class has default constructor, we can try using it as the instance and passing ALL args to the method."
                 // So the command looks like: jcli Class method [args...]
                 return "jcli ${classInfo.getSimpleName()} ${methodName} ${methodArgs.join(' ')}"
            }

            return null // Cannot determine how to invoke this instance method
        }

        if (scanPackages) {
            println "Docs: Scanning packages: ${scanPackages}"
            // NOTE: scanResult is defined above
            scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(project.ext.rejectedPackages)
                .scan()
            
            // Helpers for filtering types
            def isTypeSupported = { typeSig ->
                def typeStr = typeSig.toString().replaceAll('java\\.lang\\.', '')
                def fullTypeStr = typeSig.toString()
                
                // Primitives and Arrays
                if (typeStr in ['int', 'long', 'boolean', 'double', 'float', 'short', 'byte', 'char', 'void']) return true
                if (typeStr.endsWith('[]')) return true
                
                // Core types
                if (typeStr == 'String') return true
                if (typeStr == 'CharSequence') return true
                if (typeStr == 'Object') return true
                if (typeStr == 'Class') return true
                
                // Wrappers
                if (typeStr in ['Integer', 'Long', 'Boolean', 'Double', 'Float', 'Short', 'Byte']) return true
                
                // Check if Enum
                def typeClassInfo = scanResult.getClassInfo(fullTypeStr)
                if (typeClassInfo && typeClassInfo.isEnum()) return true
                
                return false
            }

            def isReturnTypeSupported = { typeSig ->
                def typeStr = typeSig.toString()
                
                if (typeStr.contains("java.util.stream.")) return false
                if (typeStr == "java.util.Iterator") return false
                if (typeStr == "java.util.Spliterator") return false
                if (typeStr == "java.util.Enumeration") return false
                
                def typeClassInfo = scanResult.getClassInfo(typeStr)
                if (typeClassInfo) {
                    if (typeClassInfo.implementsInterface("java.util.Iterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Spliterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Enumeration")) return false
                    if (typeClassInfo.implementsInterface("java.util.stream.BaseStream")) return false
                }
                
                return true
            }

            scanResult.getAllClasses().forEach { classInfo ->
                if (project.ext.shouldProcessClass(classInfo)) {
                     
                     def methods = []
                     classInfo.getMethodInfo().each { method ->
                          if (method.isPublic() && !method.isConstructor()) {
                               def returnTypeSig = method.getTypeSignatureOrTypeDescriptor().getResultType()
                               def paramInfos = method.getParameterInfo()
                               
                               def allParamsSupported = paramInfos.every { param ->
                                   isTypeSupported(param.getTypeDescriptor())
                               }
                               
                               if (allParamsSupported && isReturnTypeSupported(returnTypeSig)) {
                                   def exampleCmd = generateExample(classInfo, method)
                                   
                                   // CRITICAL FILTER: Only include if we have a valid example
                                   if (exampleCmd != null) {
                                       methods << [
                                           name: method.getName(),
                                           signature: "${method.getName()}(${formatParams(method).join(', ')})",
                                           returnType: returnTypeSig.toString().replaceAll('java\\.lang\\.', ''),
                                           isStatic: method.isStatic(),
                                           example: exampleCmd
                                       ]
                                   }
                               }
                          }
                     }

                     if (!methods.isEmpty()) {
                         docsData.commands << [
                             name: classInfo.getSimpleName(),
                             fullName: classInfo.getName(),
                             description: "Wrapper for ${classInfo.getName()}",
                             methods: methods.sort { it.name }
                         ]
                     }
                }
            }
        }
        
        docsData.commands.sort { it.name }
        
        docsFile.parentFile.mkdirs()
        docsFile.text = new JsonBuilder(docsData).toPrettyString()
        println "Generated docs/data.json with ${docsData.commands.size()} commands."
    }
}


processResources.dependsOn generateReflectConfig
