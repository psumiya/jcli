buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.2")
        classpath("io.github.classgraph:classgraph:4.8.165")
    }
}

plugins {
    id("com.gradleup.shadow") version "9.3.0"
    id("java")
    id("application")
    id("org.graalvm.buildtools.native") version "0.11.2"
}



version = "0.0.2-beta"
group = "jcli"

repositories {
    mavenCentral()
}

dependencies {
    annotationProcessor("info.picocli:picocli-codegen:4.6.3")
    implementation("info.picocli:picocli:4.6.3")
    implementation("org.yaml:snakeyaml:2.2")
    implementation("org.slf4j:slf4j-nop:2.0.9")
    implementation("com.jayway.jsonpath:json-path:2.9.0")
    implementation("net.minidev:json-smart:2.5.0")
    
    // Test dependencies
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.1")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.1")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

application {
    mainClass.set("jcli.JcliCommand")
}


java {
    sourceCompatibility = JavaVersion.VERSION_19
    targetCompatibility = JavaVersion.VERSION_19
}

graalvmNative {
    binaries {
        main {
            imageName.set("jcli") 
            buildArgs.add("--verbose")
        }
    }
}

test {
    useJUnitPlatform()
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}", "-parameters"]
}

import org.yaml.snakeyaml.Yaml
import groovy.json.JsonBuilder
import io.github.classgraph.ClassGraph





task packageNative(type: Tar) {
    dependsOn 'nativeCompile'
    description = "Packages the native binary into a tar.gz for distribution"
    group = "distribution"

    def arch = System.getProperty("os.arch")
    // Normalize architecture names
    if (arch == "amd64") arch = "x86_64"
    
    // We assume OSX for now as per requirements, but could expand later
    archiveFileName = "jcli-${project.version}-osx-${arch}.tar.gz"
    destinationDirectory = file("${buildDir}/distributions")
    compression = Compression.GZIP



    into("bin") {
        from("build/native/nativeCompile") {
            include "jcli"
        }
    }
    
    doLast {
        println "Created distribution: ${destinationDirectory.get()}/${archiveFileName.get()}"
    }
}

task generateReflectConfig {
    def commandsFile = file("src/main/resources/commands.yaml")
    def reflectConfigFile = file("src/main/resources/META-INF/native-image/jcli/jcli/reflect-config.json")
    def commandIndexFile = file("src/main/resources/command-index.json")
    
    inputs.file(commandsFile)
    outputs.file(reflectConfigFile)
    outputs.file(commandIndexFile)
    
    doLast {
        if (!commandsFile.exists()) {
             throw new GradleException("commands.yaml not found at ${commandsFile}")
        }
        
        def yaml = new Yaml()
        def data = yaml.load(commandsFile.newInputStream())
        def explicitCommands = data['commands'] ?: [] // Handle null if only scanPackages is present
        // Extract command list from the nested structure if it exists, or treat it as list of maps
        if (data['commands'] instanceof List) {
             explicitCommands = data['commands']
        }
        
        def scanPackages = data['scanPackages'] ?: []
        
        def reflectionEntries = []
        def commandIndex = [:]
        
        // 1. Process explicitly defined commands
        explicitCommands.each { cmd ->
            if (cmd instanceof Map && cmd.containsKey('className')) {
                reflectionEntries << [
                    name: cmd['className'],
                    queryAllPublicMethods: true
                ]
            }
        }
        
        // 2. Scan packages
        if (scanPackages) {
            println "Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(
                    "java.util.concurrent", 
                    "java.util.concurrent",
                    "java.util.jar",
                    "java.util.logging",
                    "java.util.prefs",
                    "java.util.random",
                    "java.util.regex",
                    "java.util.spi",
                    "java.util.stream",
                    "java.util.zip",
                    "java.lang.invoke", 
                    "java.lang.instrument", 
                    "java.lang.reflect", 
                    "java.lang.management",
                    "java.lang.module",
                    "java.lang.ref",
                    "java.lang.foreign",
                    "java.util.function",
                    "java.lang.annotation",
                    "java.lang.classfile",
                    "java.lang.constant",
                    "com.jayway.jsonpath.internal",
                    "com.jayway.jsonpath.spi"
                )
                .rejectClasses(
                  //  'com.jayway.jsonpath.Configuration', 
                  //  'com.jayway.jsonpath.Configuration$ConfigurationBuilder',
                  //  'com.jayway.jsonpath.Criteria',
                  //  'com.jayway.jsonpath.Option'
                )
                .scan()
            
            scanResult.getAllClasses().forEach { classInfo ->
                if (classInfo.isPublic() && !classInfo.isAbstract() && !classInfo.isInnerClass() && 
                    !classInfo.extendsSuperclass("java.lang.Throwable") &&
                    !classInfo.implementsInterface("java.util.Collection") &&
                    !classInfo.implementsInterface("java.util.Map") &&
                    !classInfo.implementsInterface("java.util.Iterator") &&
                    !classInfo.getName().startsWith("java.util.Optional") &&
                    !classInfo.getName().startsWith("java.util.Observable") &&
                    !classInfo.getName().equals("java.util.BitSet") &&
                    !classInfo.getName().equals("java.util.EventObject") &&
                    !classInfo.getName().equals("java.util.ServiceLoader") &&
                    !classInfo.getName().equals("java.util.Timer") &&
                    !classInfo.getName().equals("java.util.StringJoiner") &&
                    !classInfo.getName().equals("java.util.StringTokenizer") &&
                    !classInfo.getName().equals("java.util.PropertyResourceBundle") &&
                    !classInfo.getName().equals("java.util.PropertyPermission") &&
                    !classInfo.getName().equals("java.util.SimpleTimeZone") &&
                    !classInfo.getName().equals("java.util.Collections") &&
                    !classInfo.getName().endsWith("SummaryStatistics") &&
                    !classInfo.getName().equals("java.util.FormattableFlags") &&
                    !classInfo.getName().equals("java.util.GregorianCalendar")) {
                     def className = classInfo.getName()
                     def simpleName = classInfo.getSimpleName()
                     
                     // Add to reflection config
                     def methodsList = []
                     classInfo.getMethodInfo().each { method ->
                         if (method.isPublic()) {
                             def parameterTypes = method.getParameterInfo().collect { it.getTypeSignatureOrTypeDescriptor().toString() }
                             methodsList << [
                                 name: method.getName(),
                                 parameterTypes: parameterTypes
                             ]
                         }
                     }

                     reflectionEntries << [
                         name: className,
                         queryAllPublicMethods: true,
                         allDeclaredConstructors: true,
                         allPublicConstructors: true,
                         methods: methodsList
                     ]
                     
                     // Add to command index (SimpleName -> FullName)
                     // If collision, keep existing (first wins) or warn? For now, silent overwrite or ignore. 
                     // Let's protect against duplicates by checking.
                     if (!commandIndex.containsKey(simpleName)) {
                         commandIndex[simpleName] = className
                     }
                }
            }
        }

        // Add CommandConfig for generic command loading
        reflectionEntries << [
            name: "jcli.config.CommandConfig",
            allDeclaredConstructors: true,
            allPublicConstructors: true,
            allDeclaredFields: true,
            allPublicMethods: true
        ]
        
        reflectConfigFile.parentFile.mkdirs()
        reflectConfigFile.text = new JsonBuilder(reflectionEntries).toPrettyString()
        
        commandIndex.each { k, v -> 
            println "Indexed: ${k} -> ${v}" 
        }
        
        commandIndexFile.parentFile.mkdirs()
        commandIndexFile.text = new JsonBuilder(commandIndex).toPrettyString()
        
        println "Generated reflect-config.json with ${reflectionEntries.size()} entries."
        println "Generated command-index.json with ${commandIndex.size()} entries."
    }
}

task generateDocsJson {
    dependsOn 'classes' // Need compiled classes for reflection/scanning if we used that, but here we use ClassGraph which scans classpath
    description = "Generates JSON data for the documentation site"
    group = "documentation"

    def docsFile = file("docs/data.json")
    def commandsFile = file("src/main/resources/commands.yaml")
    
    inputs.file(commandsFile)
    outputs.file(docsFile)
    
    doLast {
        def yaml = new Yaml()
        def data = commandsFile.exists() ? yaml.load(commandsFile.newInputStream()) : [:]
        def scanPackages = data['scanPackages'] ?: []
        
        def docsData = [
            generatedAt: new Date().toString(),
            version: project.version,
            commands: []
        ]
        
        // Helper to formatting method params
        // Helper to formatting method params
        def formatParams = { method ->
             def params = method.getParameterInfo()
             params.indices.collect { i ->
                 def param = params[i]
                 def typeName = param.getTypeDescriptor().toString().replaceAll('java\\.lang\\.', '').replaceAll('java\\.util\\.', '')
                 def paramName = param.getName()
                 if (paramName == null) paramName = "arg${i}"
                 "${typeName} ${paramName}"
             }
        }

        if (scanPackages) {
            println "Docs: Scanning packages: ${scanPackages}"
            def scanResult = new ClassGraph()
                .overrideClasspath(sourceSets.main.runtimeClasspath)
                .enableAllInfo()
                .enableSystemJarsAndModules()
                .acceptPackages(scanPackages as String[])
                .rejectPackages(
                    "java.util.concurrent", 
                    "java.util.concurrent",
                    "java.util.jar",
                    "java.util.logging",
                    "java.util.prefs",
                    "java.util.random",
                    "java.util.regex",
                    "java.util.spi",
                    "java.util.stream",
                    "java.util.zip",
                    "java.lang.invoke", 
                    "java.lang.instrument", 
                    "java.lang.reflect", 
                    "java.lang.management",
                    "java.lang.module",
                    "java.lang.ref",
                    "java.lang.foreign",
                    "java.util.function",
                    "java.lang.annotation",
                    "java.lang.classfile",
                    "java.lang.constant",
                    "com.jayway.jsonpath.internal",
                    "com.jayway.jsonpath.spi"
                )
                .scan()
            
            // Helpers for filtering
            def isTypeSupported = { typeSig ->
                def typeStr = typeSig.toString().replaceAll('java\\.lang\\.', '')
                def fullTypeStr = typeSig.toString()
                
                // Primitives and Arrays
                if (typeStr in ['int', 'long', 'boolean', 'double', 'float', 'short', 'byte', 'char', 'void']) return true
                if (typeStr.endsWith('[]')) return true
                
                // Core types
                if (typeStr == 'String') return true
                if (typeStr == 'CharSequence') return true
                if (typeStr == 'Object') return true
                if (typeStr == 'Class') return true
                
                // Wrappers
                if (typeStr in ['Integer', 'Long', 'Boolean', 'Double', 'Float', 'Short', 'Byte']) return true
                
                // Check if Enum
                def typeClassInfo = scanResult.getClassInfo(fullTypeStr)
                if (typeClassInfo && typeClassInfo.isEnum()) return true
                
                return false
            }

            def isReturnTypeSupported = { typeSig ->
                def typeStr = typeSig.toString()
                
                // Quick string checks
                if (typeStr.contains("java.util.stream.")) return false
                if (typeStr == "java.util.Iterator") return false
                if (typeStr == "java.util.Spliterator") return false
                if (typeStr == "java.util.Enumeration") return false
                
                def typeClassInfo = scanResult.getClassInfo(typeStr)
                if (typeClassInfo) {
                    if (typeClassInfo.implementsInterface("java.util.Iterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Spliterator")) return false
                    if (typeClassInfo.implementsInterface("java.util.Enumeration")) return false
                    if (typeClassInfo.implementsInterface("java.util.stream.BaseStream")) return false
                }
                
                return true
            }

            scanResult.getAllClasses().forEach { classInfo ->
                if (classInfo.isPublic() && !classInfo.isAbstract() && !classInfo.isInnerClass() && 
                    !classInfo.extendsSuperclass("java.lang.Throwable") &&
                    !classInfo.implementsInterface("java.util.Collection") &&
                    !classInfo.implementsInterface("java.util.Map") &&
                    !classInfo.implementsInterface("java.util.Iterator") &&
                    !classInfo.getName().startsWith("java.util.Optional") &&
                    !classInfo.getName().startsWith("java.util.Observable") &&
                    !classInfo.getName().equals("java.util.BitSet") &&
                    !classInfo.getName().equals("java.util.EventObject") &&
                    !classInfo.getName().equals("java.util.ServiceLoader") &&
                    !classInfo.getName().equals("java.util.Timer") &&
                    !classInfo.getName().equals("java.util.StringJoiner") &&
                    !classInfo.getName().equals("java.util.StringTokenizer") &&
                    !classInfo.getName().equals("java.util.PropertyResourceBundle") &&
                    !classInfo.getName().equals("java.util.PropertyPermission") &&
                    !classInfo.getName().equals("java.util.SimpleTimeZone") &&
                    !classInfo.getName().equals("java.util.Collections") &&
                    !classInfo.getName().endsWith("SummaryStatistics") &&
                    !classInfo.getName().equals("java.util.FormattableFlags") &&
                    !classInfo.getName().equals("java.util.GregorianCalendar") &&
                    !classInfo.getName().startsWith("com.jayway.jsonpath.internal") &&
                    !classInfo.getName().startsWith("com.jayway.jsonpath.spi")) {
                     
                     def methods = []
                     classInfo.getMethodInfo().each { method ->
                          if (method.isPublic() && !method.isConstructor()) {
                              def returnTypeSig = method.getTypeSignatureOrTypeDescriptor().getResultType()
                              def paramInfos = method.getParameterInfo()
                              
                              def allParamsSupported = paramInfos.every { param ->
                                  isTypeSupported(param.getTypeDescriptor())
                              }
                              
                              if (allParamsSupported && isReturnTypeSupported(returnTypeSig)) {
                                  methods << [
                                      name: method.getName(),
                                      signature: "${method.getName()}(${formatParams(method).join(', ')})",
                                      returnType: returnTypeSig.toString().replaceAll('java\\.lang\\.', ''),
                                      isStatic: method.isStatic()
                                  ]
                              }
                          }
                     }

                     docsData.commands << [
                         name: classInfo.getSimpleName(),
                         fullName: classInfo.getName(),
                         description: "Wrapper for ${classInfo.getName()}",
                         methods: methods.sort { it.name }
                     ]
                }
            }
        }
        
        docsData.commands.sort { it.name }
        
        docsFile.parentFile.mkdirs()
        docsFile.text = new JsonBuilder(docsData).toPrettyString()
        println "Generated docs/data.json with ${docsData.commands.size()} commands."
    }
}


processResources.dependsOn generateReflectConfig
