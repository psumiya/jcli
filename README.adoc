= jcli
:nofooter:

Sugared wrappers to execute methods from JDK and JVM-based libraries from the command line.

E.g., To generate a UUID, `java.util.UUID` contains a method `randomUUID()`. This tool helps you execute that method by invoking `jcli uuid randomUUID`.

== Motivation
The goal is to expose the wealth of utility methods available in the JVM ecosystem right at the command line.

It is also intended that this be a GraalVM-compatible project so that distributions do not require the end user to do a JVM setup with some compatible Java version.

Most methods return a single result, and so can be used in pipe operations combined with other command line utilities if needed.

== Auto-Discovery & Configuration

`jcli` uses **Build-Time Package Scanning** to automatically discover and register commands.

The configuration is simple. In `src/main/resources/commands.yaml`:

```yaml
scanPackages:
  - java.lang
  - java.util
  - java.time
```

During the build, `jcli` scans these packages and registers classes as commands using their **SimpleName** (e.g., `java.lang.Math` -> `Math`).

=== Automatic Filtering
To keep the CLI useful and focused on command-line relevant utilities, `jcli` **automatically excludes**:

*   **Collections**: `ArrayList`, `HashMap`, `HashSet`, etc. (Creating empty containers is rarely useful in a CLI).
*   **I/O & Streams**: `ZipFile`, `Scanner`, `InputStream`, etc.
*   **Infrastructure**: `java.util.concurrent`, `java.util.logging`, `java.util.prefs`.
*   **Reflection**: `java.lang.reflect`, `java.lang.invoke`.
*   **Exceptions**: All classes extending `Throwable`.
*   **Unsupported Return Types**: Methods returning `Stream`, `Iterator`, or `Spliterator` are hidden to prevent unusable output.

NOTE: If you try to call an excluded method, `jcli` will provide a diagnostic error explaining exactly why it is not available.

This results in a clean, high-signal list of commands focused on **Values** (String, Integer) and **Utilities** (Math, Time, UUID).

== Available Commands

With the default configuration, you get access to ~100 powerful Java commands, including:

*   **Core**: `String`, `Math`, `Integer`, `Boolean`, `System`
*   **Time**: `LocalDate`, `LocalTime`, `Instant`, `Duration`, `Period`, `ZoneId`
*   **Utils**: `UUID`, `Base64`, `Objects`, `Random`, `Currency`

=== Examples

[cols="1,1,1,1"]
|===
|Command | Method | Description | Usage

|`UUID`
|`randomUUID`
|Generates a random UUID
|`jcli UUID randomUUID`

|`LocalDate`
|`now`
|Prints the current date
|`jcli LocalDate now`

|`String`
|`length`
|Returns string length (instance method)
|`jcli String length "hello world"`

|`Math`
|`max`
|Returns the greater of two values
|`jcli Math max 10 20`

|`Instant`
|`getEpochSecond`
|Parses text to Instant (Smart Factory)
|`jcli Instant getEpochSecond "2023-01-01T00:00:00Z"`
|===

== Build

To build this project's source code:

. Clone this project
. At the root of the project, execute `./gradlew clean build`
. The build generates a jar at `build/libs`. To execute the cli app, run `java -jar build/libs/jcli-0.1-all.jar -h` to view the help manual.

== Build Native Image

 . Install and Use GraalVM for JDK 21
 . Compile Native Image
 .. NativeCompile may take a few minutes
 
 ```
 sdk install java 21.0.1-graal
 sdk use java 21.0.1-graal
 ./gradlew nativeCompile
 ```
 
 The default output directory is `build/native/nativeCompile`.
 
 Here is how you can execute the native file.
 ```
 $ ./build/native/nativeCompile/jcli --help
 ```
 
 **Note on Native Image**: The build automatically generates the `reflect-config.json` based on your `commands.yaml`. You do **not** need to manually edit any JSON files. Simply add your command to the YAML and rebuild (`./gradlew build` or `./gradlew nativeCompile`).