= jcli
:nofooter:

Sugared wrappers to execute methods from JDK and JVM-based libraries from the command line.

== How to Use

E.g., To generate a UUID, `java.util.UUID` contains a method `randomUUID()`. This tool helps you execute that method by invoking `jcli uuid randomUUID`.

== Installation

You can install `jcli` via Homebrew.

[source,bash]
----
brew tap psumiya/jcli
brew install jcli
----

== Motivation

`jcli` aims to provide a convenient way to execute common JDK and JVM-based library methods directly from the command line, without writing boilerplate Java code.

For example, to get the current date:

    jcli LocalDate now

Or to calculate the max of two numbers:

    jcli Math max 10 20

Or to query a JSON using JsonPath:

    jcli JsonPath read '{"key":"value"}' "$.key"

== Build

You can build `jcli` as a standard runnable JAR or as a native executable using GraalVM.

=== Prerequisites



*   **Java 25** (for standard build)
*   **GraalVM for Java 25** (for native build)

[source,bash]
----
# Install GraalVM for Java 25
sdk install java 25.0.1-graalce
sdk use java 25.0.1-graalce
----

=== Standard Build (JVM)

To build the standard executable JAR:

1.  Clone the project.
2.  Run the build:
    [source,bash]
    ----
    ./gradlew clean build
    ----
3.  Execute the JAR:
    [source,bash]
    ----
    java -jar build/libs/jcli-0.0.2-beta-all.jar -h
    ----

=== Native Build (GraalVM)

To compile a standalone native executable (faster startup, no JVM required at runtime):

1.  Ensure you are using GraalVM 25:
    [source,bash]
    ----
    sdk use java 25.0.1-graalce
    ----
2.  Run the native compile task (this may take a few minutes):
    [source,bash]
    ----
    ./gradlew nativeCompile
    ----
3.  The executable is generated at `build/native/nativeCompile/jcli`.
4.  Execute it directly:
    [source,bash]
    ----
    ./build/native/nativeCompile/jcli --help
    ----

== Available Commands

`jcli` uses **Build-Time Package Scanning** to automatically discover and register commands from configured packages.

=== Automatic Filtering

To provide a clean and useful CLI experience, `jcli` aggressively filters out classes that are not typically useful for command-line one-off tasks.

**Excluded Categories:**

*   **Collections**: `ArrayList`, `HashMap`, `HashSet`, etc.
*   **I/O & Streams**: `ZipFile`, `Scanner`, `InputStream`, `OutputStream`.
*   **Concurrency**: `java.util.concurrent.*`.
*   **Reflection & Infrastructure**: `java.lang.reflect`, `java.lang.invoke`, `java.util.logging`.
*   **Exceptions**: Any class extending `Throwable`.
*   **Complex Return Types**: Methods returning `Stream`, `Iterator`, or `Spliterator`.

**Included Categories:**

*   **Core Values**: `String`, `Math`, `Integer`, `Boolean`.
*   **Time & Date**: `LocalDate`, `LocalTime`, `Instant`, `Duration`, `Period`.
*   **Utilities**: `UUID`, `Base64`, `Objects`, `Random`, `Currency`.

If you attempt to call a filtered/excluded class, `jcli` will provide a helpful error message explaining why it is not available.

== How to Add Packages

You can extend `jcli` to support more libraries or packages by modifying the configuration.

1.  Open `src/main/resources/commands.yaml`.
2.  Add the package you want to scan under `scanPackages`.

    ```yaml
    scanPackages:
      - java.lang
      - java.util
      - java.time
      - your.custom.package  # <--- Add this
    ```

3.  **Rebuild**:
    *   For JVM: `./gradlew build`
    *   For Native: `./gradlew nativeCompile`

During the build, `jcli` will:

*   Scan the new package.
*   Apply the filtering rules.
*   Automatically generate `reflect-config.json` for GraalVM compatibility.